---
title: å¹¶å‘ç¼–ç¨‹
date: 2022-04-26
extra:
  add_toc: true
  katex: true
taxonomies:
  categories:
    - ç¬”è®°
  tags:
    - å¹¶å‘
---

> æ¥è‡ªï¼š[2022 æ˜¥å­£å—äº¬å¤§å­¦æ“ä½œç³»ç»Ÿå…¬å¼€è¯¾(è’‹ç‚å²©)](https://www.bilibili.com/video/BV1Cm4y1d7Ur/) å¤šå¤„ç†å™¨ç¼–ç¨‹éƒ¨åˆ†

# å…¥é—¨å¤šå¤„ç†å™¨ç¼–ç¨‹

> Concurrent: existing, happening, or done at the same time.
> In computer science, concurrency refers to the ability of different parts or units of a program,
> alogrithmn, or problem to be executed out-of-order or in partial order, without affecting the
> final outcome. (Wikipedia)

ç³»ç»Ÿè°ƒç”¨çš„ä»£ç æ˜¯ä¸–ç•Œä¸Šæœ€æ—©çš„å¹¶å‘ç¨‹åº

> äººç±»æ§åˆ¶ä¸äº†å¹¶å‘æ‰€å¸¦æ¥çš„ç¾éš¾ï¼Œäººç±»åªèƒ½å†™å¥½èƒ½æ§åˆ¶çš„äº†çš„ä»£ç 

## çŠ¶æ€æœº

1. å¤šçº¿ç¨‹ç¨‹åºæ¯ä¸€ä¸ªçº¿ç¨‹å¯¹åº”ä¸€ä¸ªçŠ¶æ€æœºï¼Œæ¯åˆ›å»ºä¸€ä¸ªçº¿ç¨‹å°±æ˜¯åˆ›å»ºä¸€ä¸ªçŠ¶æ€æœº
1. ä¸åŒçš„çŠ¶æ€æœºçš„çŠ¶æ€è½¬ç§»éƒ½å¯ä»¥åœ¨ä¸åŒ cpu ä¸Šå¹¶è¡Œè¿è¡Œ

## åŸå­æ€§

> ä¸€æ®µä»£ç æ‰§è¡Œç‹¬å æ•´ä¸ªè®¡ç®—æœºç³»ç»Ÿ

### ç ´ååŸå­æ€§

- å•å¤„ç†å™¨å¤šçº¿ç¨‹

çº¿ç¨‹åœ¨è¿è¡Œæ—¶å¯èƒ½è¢«æ‰“æ–­ï¼Œåˆ‡æ¢åˆ°å¦ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œï¼Œè¿™ä¼šæ‰“ç ´åŸå­æ€§

> å¦‚æœç¼–è¯‘åçš„æŒ‡ä»¤åªæœ‰ä¸€æ¡çš„è¯é‚£ä¹ˆä¸ä¼šç ´ååŸå­æ€§ï¼Œæ¯”å¦‚ add æŒ‡ä»¤
> çº¿ç¨‹åœ¨ä¸€ä¸ª CPU æ—¶é—´ç‰‡é‡Œé€šå¸¸ä¼šè‡³å°‘æ‰§è¡Œä¸€ä¸ªæŒ‡ä»¤ï¼Œå•å¤„ç†å™¨æ¯ä¸ªç‰©ç†æ—¶åˆ»
> åªä¼šæ‰§è¡ŒæŸä¸ªç¨‹åºçš„æŸä¸ªæŒ‡ä»¤ï¼Œæ‰€ä»¥æŒ‡ä»¤çš„æ‰§è¡Œæ˜¯ä¸²è¡Œçš„ï¼Œè¿™å¯ä»¥ä¿è¯
> åŸå­æ€§

- å¤šå¤„ç†å™¨å¤šçº¿ç¨‹

çº¿ç¨‹å¯ä»¥åœ¨ä¸åŒå¤„ç†å™¨å¹¶è¡Œæ‰§è¡Œï¼Œè¿™æœ¬å°±æ˜¯éåŸå­æ€§çš„

> ç¼–è¯‘åçš„æŒ‡ä»¤å³ä½¿åªæœ‰ä¸€ä¸ªä¹Ÿä¼šç ´ååŸå­æ€§
> å¤šå¤„ç†å™¨ä¸­çš„å¤šçº¿ç¨‹å¯ä»¥è¿è¡Œåœ¨ä¸åŒçš„å¤„ç†å™¨ä¸Šï¼Œå³ä½¿ç¼–è¯‘ååªæœ‰ä¸€ä¸ªæŒ‡ä»¤
> ä¹Ÿå¯èƒ½ä¼šå¯¼è‡´è¿™æ¡æŒ‡ä»¤è¢«å¤šä¸ªå¤„ç†å™¨åŒæ—¶æ‰§è¡Œç ´ååŸå­æ€§

### å®‰å…¨çš„ printf

> printf æ€»æ˜¯å¯ä»¥æ­£å¸¸å·¥ä½œï¼Œå› ä¸ºå®ƒæ˜¯çº¿ç¨‹å®‰å…¨çš„

### å®ç°åŸå­æ€§

> äº’æ–¥

- lock(&lk)
- unlock(&lk)

ä½¿ç”¨é”å»ä¿è¯æŒ‡ä»¤æ‰§è¡Œçš„ä¸²è¡Œ

## é¡ºåºæ€§

> æŒ‡ä»¤åœ¨ç³»ç»Ÿæ‰§è¡Œçš„é¡ºåºæ€§

### ç ´åé¡ºåºæ€§

- ç¼–è¯‘ä¼˜åŒ–

  > ç¼–è¯‘å™¨å¯ä»¥åœ¨å¯è§çš„ä¸²è¡Œé€»è¾‘ä¸­ä¼˜åŒ–é€»è¾‘
  > **è¿™å¯èƒ½ä¸èƒ½ä¿è¯å¹¶å‘è¿è¡Œçš„é¡ºåºé€»è¾‘æ­£å¸¸** 
  >
  > æ¯”å¦‚
  >
  > ```c
  > extern int done;
  > void join() {
  >     while (!done) {
  >     }
  > }
  > ```
  >
  >å¸Œæœ›çº¿ç¨‹äºŒå¯ä»¥æ”¹å˜ done æ¥æ§åˆ¶ join é€€å‡º
  > å¯èƒ½ä¼šè¢«ä¼˜åŒ–æˆ `if (!done) while(1)`
  
- æŒ‡ä»¤é‡æ’
  > ç°ä»£å¤„ç†å™¨å…¶å®ä¹Ÿæ˜¯ä¸€ç§ç¼–è¯‘å™¨
  > å®ƒå¯ä»¥å°†æ±‡ç¼–ä»£ç è½¬åŒ–æˆå¤„ç†å™¨è¿è¡Œçš„æ›´å°çš„æ“ä½œ $\mu ops$ï¼š
  > fetch -> issue -> execute -> commit

> ç°ä»£å¤„ç†å™¨å¯ä»¥ä¿è¯åœ¨å¯è§çš„æµç¨‹ä¸­ä¸æ”¹å˜è¾“å‡ºç»“æœä»è€Œè‡ªè¡Œç¼–æ’$\mu ops$
> å¦‚ä¸€èµ· issue å¤šæ¡æŒ‡ä»¤ï¼Œé‚£ä¹ˆåˆ°åº•å“ªä¸ªæŒ‡ä»¤å…ˆæ‰§è¡Œå°±ä¸å¾—è€ŒçŸ¥äº†
> æ¯”å¦‚å¯¹åº”åˆ°çŠ¶æ€æœºçš„çŠ¶æ€è¿ç§»:
>
> ```c
> x=1;
> y=1;
> printf("%d, %d", x, y);
> ```
>
>
> å¯ä»¥è¢«é‡æ’ä¸º
>
> ```c
> y=1;
> x=1;
> printf("%d, %d", x, y);
> ```
>
>
> **ä½†æ˜¯å¤šçº¿ç¨‹ç¨‹åºçš„æµç¨‹æ˜¯æ— æ³•é¢„çŸ¥çš„** > **å¤šçº¿ç¨‹ç¨‹åºä¸­æŸä¸€ä¸ªçº¿ç¨‹å¯ä»¥ä¿è¯è¯¥çº¿ç¨‹å•ç‹¬è¿è¡Œæ—¶çš„é¡ºåºæ€§ä¸ä¼šè¢«æŒ‡ä»¤é‡æ’æ‰“ä¹±** > **ä½†æ˜¯ä¸èƒ½ä¿è¯å¾ˆå¤šçº¿ç¨‹åŒæ—¶è¿è¡Œæ—¶ç³»ç»Ÿçš„é¡ºåºæ€§ä¸è¢«æŒ‡ä»¤é‡æ’åºæ‰“ä¹±**

## å¯è§æ€§

> ç³»ç»Ÿä¸­ä¸åŒçº¿ç¨‹ä¹‹é—´çš„èµ„æºå¯è§æ€§

- æŒ‡ä»¤é‡æ’
  > ç»§ä¸Šé¢çš„æŒ‡ä»¤é‡æ’
  > æ¯ä¸€æ¬¡ç”±äº cpu çš„æŒ‡ä»¤é‡æ’åºå¯èƒ½ä¼šç ´åå¹¶å‘ç¨‹åºçš„é¡ºåºé€»è¾‘
  > **æŒ‡ä»¤çš„é‡æ–°æ’åºä¸æ˜¯æ²¡æœ‰è§„åˆ™çš„ï¼Œå®ƒä¸ä¼šå°†äº’ç›¸ä¾èµ–çš„æŒ‡ä»¤é‡æ’åº** 
  >
  > **ä¾‹å¦‚ x = 1; y = x ä¸ä¼šé‡æ’æˆ y=x; x=1** 
  >
  > **å¤šæ ¸ CPU å†…éƒ¨ä¼šç»´æŠ¤ä¸€ä¸ªæŒ‡ä»¤ä¾èµ–æ€§çš„æœ‰å‘æ— ç¯å›¾(æ— ç¯æ˜¯å› ä¸ºç°åœ¨çš„æŒ‡ä»¤ä¸ä¼šä¾èµ–æœªæ¥çš„æŒ‡ä»¤)**  
  >
  > **ä»è€Œå°½å¯èƒ½å¤šåœ°å°†æ²¡æœ‰ä¾èµ–æ€§çš„æŒ‡ä»¤ä¸€èµ· issue å‡ºå»æ‰§è¡Œï¼Œä»¥æå‡æ•ˆç‡**  
  >
  > **ä½†æ˜¯å¹¶å‘ç¨‹åºä¹‹é—´çš„é€»è¾‘ä¾èµ–å¤šæ ¸ CPU æ˜¯ä¸å¯è§çš„ï¼Œå°±æ˜¯ä¸Šé¢è¯´çš„å¤šçº¿ç¨‹ç¨‹åºçš„æµç¨‹æ˜¯æ— æ³•é¢„çŸ¥çš„** 
  >
  > **ä¾‹å¦‚åœ¨ A çº¿ç¨‹é‡Œ x = 1; printf(y); åœ¨ B çº¿ç¨‹é‡Œ y = 1ï¼›printf(x); å¯èƒ½ä¼šå¯¼è‡´è¾“å‡º 0 0 çš„åå¸¸æƒ…å†µ, å› ä¸º B** 
  >
  > **çº¿ç¨‹é‡Œçš„ printf(x) ä¸ A çº¿ç¨‹é‡Œçš„ x = 1 æ²¡æœ‰å¯è§æ€§ï¼Œæ„å»ºä¸äº†(å¾ˆéš¾æ„å»º)ä¾èµ–å…³ç³»ã€‚é‚£ä¹ˆå¦‚æœ x = 1 å¯¹ x å†™çš„** 
  >
  > **æ—¶å€™ç¼“å­˜æ²¡æœ‰å‘½ä¸­, å°±ä¼šæš‚æ—¶æ”¾ä¸€æ”¾ xï¼Œå…ˆå¯¹ y è¯»å–ï¼Œè¿™æ—¶çº¿ç¨‹ B ä¹Ÿæ˜¯è¿™æ ·çš„è¯è¯»å–åˆ°çš„ x å’Œ y éƒ½æ˜¯ 0** 
  >
  > **çº¿ç¨‹ä¹‹é—´çš„é€»è¾‘äº’ç›¸æ²¡æœ‰å¯è§æ€§ï¼Œä¸€åˆ‡çš„é€»è¾‘ä¼˜åŒ–éƒ½å¯èƒ½ä¼šå¯¼è‡´å¹¶å‘ç¨‹åºå‡ºé—®é¢˜**

## ä¸€è‡´æ€§

> ç³»ç»Ÿä¸­ä¸åŒçº¿ç¨‹ä¹‹é—´å¯¹èµ„æºæ“ä½œä¸è®¿é—®çš„ä¸€è‡´æ€§

- **ç¼“å­˜**

  > å†…å­˜çš„é€Ÿåº¦ç»ˆç©¶æ˜¯è¾¾ä¸åˆ° CPU è®¡ç®—çš„é€Ÿåº¦(DDR4 3200MHz vs 5.0GHz)
  > ç¼“å­˜å°±æ˜¯æ‹¿æ¥è¡¥å†…å­˜é€Ÿåº¦ä¸è¶³çš„çŸ­æ¿çš„ï¼ŒL1, L2, L3 çº§ç¼“å­˜ç­‰ç­‰
  > **æœ‰äº†ç¼“å­˜ï¼ŒåŠ å¿«çš„è®¡ç®—æœºå¤„ç†çš„é€Ÿåº¦ï¼Œå¯ç‰ºç‰²çš„æ˜¯å¤šçº¿ç¨‹ä¹‹é—´çš„å¯è§æ€§å’Œä¸€è‡´æ€§**

- **å†…å­˜æ¨¡å‹**
  > **x86 çš„å†…å­˜æ¨¡å‹ä¸ºè®¡ç®—æœºä¿è¯äº†ä¸€è‡´æ€§ï¼Œå¯ä»¥åœ¨ä¸Šé¢ write x å’Œ read y ä¹‹é—´æ’å…¥ä¸€æ¡åŸå­æŒ‡ä»¤** 
  >
  > **æˆ–è€… fence æŒ‡ä»¤ï¼Œè¿™å°±ä¼šå¼ºåˆ¶å°† x å†™å…¥å…±äº«å†…å­˜å†å»è¯»å– yï¼Œå¯è¿™æ ·å°±ç‰ºç‰²äº†æ€§èƒ½ã€‚** 
  >
  > **è€Œ arm ç­‰æ¶æ„çš„å†…å­˜æ¨¡å‹çš„è®¡ç®—æœºæ¯ä¸€ä¸ªå¤„ç†å™¨ä¼šæœ‰ä¸€ä»½å•ç‹¬çš„å†…å­˜ï¼Œå†…å­˜ä¹‹é—´éšæ—¶è¿›è¡ŒåŒæ­¥** 
  >
  > **è¿™æœ¬å°±å¾ˆéš¾ä¿è¯ä¸€è‡´æ€§**

## å…¥é—¨åˆ°æ”¾å¼ƒ

### ä¸åŸå­

> **ç”šè‡³ä¸€æ¡æŒ‡ä»¤éƒ½æ— æ³•ä¿è¯åŸå­æ€§**

### èƒ½ä¹±åº

> **ç¼–è¯‘å™¨èƒ½å¤Ÿä½¿å¹¶å‘ç¨‹åºç¼–è¯‘åçš„æŒ‡ä»¤å¯¹å†…å­˜è®¿é—®å˜å¾—ä¹±åº** > **å°±ç®—å˜æˆäº†æŒ‡ä»¤ï¼ŒCPU åœ¨å¤„ç†æŒ‡ä»¤çš„æ—¶å€™ä¹Ÿä¼šå˜å¾—ä¹±åº**

### ä¸å¯è§ä¸ä¸€è‡´

> **å¹¶å‘ç¨‹åºçš„é€»è¾‘å…³ç³»æ˜¯ä¸å¯è§çš„** > **ç¼“å­˜ä¹Ÿä¼šå¯¼è‡´èµ„æºæ“ä½œçš„ä¸å¯è§æ€§å’Œä¸ä¸€è‡´æ€§**

# ç†è§£å¹¶å‘ç¨‹åºæ‰§è¡Œ

## äº’æ–¥

### å¤±è´¥çš„äº’æ–¥

```c
int lock = UNLOCK;

void critical_section() {
retry:
    if (lock != UNLOCK) {
        goto retry;
    }
    lock = LOCK;

    // critical_section

    lock = UNLOCK
}
```

**ä¸¤ä¸ªçº¿ç¨‹å¯ä»¥åŒæ—¶è¿›å…¥ if åˆ¤æ–­å¹¶å¾—åˆ° false ç»“æœï¼Œç„¶åä¸€èµ·è¿›å…¥ critical_section**

### å¥‡æ€ªçš„äº’æ–¥å°è¯•(Peterson ç®—æ³•)

![](https://image-1259160349.cos.ap-chengdu.myqcloud.com/yuque/Fvh1OO8iEGcgWA6dehZBfMzeHeJ6.png)

> æ‰‹å¿« ğŸˆ¶ï¸ï¼Œæ‰‹æ…¢ ğŸˆšï¸
> å³ä½¿ç©·ä¸¾çŠ¶æ€æœºæ¨¡å‹çš„æ‰€æœ‰æƒ…å†µå‡è¯æ˜ peterson ç®—æ³•å¯ä»¥ä¿è¯äº’æ–¥
> **ä½†æ˜¯ä»ç„¶ä¸èƒ½ä¿è¯è¿™ä¸ªç®—æ³•åœ¨å¤šæ ¸å¤„ç†å™¨ä¸Šèƒ½æ­£å¸¸å·¥ä½œ**

## ç»˜åˆ¶çŠ¶æ€æœº

> **å¤šçº¿ç¨‹ç¨‹åºçš„æ‰§è¡Œ = çŠ¶æ€æœº** 
>
> **æ¯ä¸€æ­¥ç¡®å®šä¸€ä¸ªçŠ¶æ€æœºæ‰§è¡Œ** 
>
> **ç»˜åˆ¶çŠ¶æ€æœº**

# å¹¶å‘æ§åˆ¶

## åŸå­æ€§â€”â€”äº’æ–¥

### è‡ªæ—‹é”(spin lock)

> **åˆ©ç”¨åŸå­æŒ‡ä»¤ xchg (exchange), è¯»å–ä¸€ä¸ªå€¼å¹¶æŠŠæ‰‹ä¸Šçš„å€¼äº¤æ¢**

```c
int table = YES;

void lock() {
retry:
    int got = xchg(&table, NOPE);
    if (got == NOPE)
        goto retry;
    assert(got == YES)
}

void unlock() {
    xchg(&table, YES)
}
```

```c
int locked = 0;
void lock() { while(xchg(&locked, 1)); }
void unlock() { xchg(&locked, 0); }
```

- æ²¡æœ‰å…¶ä»–çº¿ç¨‹æˆ–è€…å¾ˆå°‘æœ‰å…¶ä»–çº¿ç¨‹æŠ¢é”çš„æƒ…å†µä¸‹åŠ é”å¾ˆå¿«(ä¸€æ¡åŸå­æŒ‡ä»¤å°±å®Œäº‹äº†)
- å¦‚æœæœ‰å¾ˆå¤šçº¿ç¨‹åœ¨æŠ¢é”çš„è¯ä¼šå¯¼è‡´è‡ªæ—‹ç­‰å¾…æµªè´¹ CPU

### äº’æ–¥é”(Mutex)

> **ç³»ç»Ÿè°ƒç”¨**

- **sysall(SYSCALL_lock, &lk);**

  > **å°è¯•è·å–é”ï¼Œä½†å¦‚æœå¤±è´¥ï¼ŒæŠŠè¿™ä¸ªçº¿ç¨‹æŒ‚èµ·ï¼Œåˆ‡æ¢åˆ°å…¶ä»–çº¿ç¨‹é‡Œæ‰§è¡Œ**

- **syscall(SYSCALL_unlock, &lk);**

  > **é‡Šæ”¾é”ï¼Œå¦‚æœæœ‰å…¶ä»–çº¿ç¨‹ç­‰å¾…è¿™æŠŠé”çš„è¯å°±å”¤é†’é‚£ä¸ªçº¿ç¨‹å»è·å–é”**

- ä¸Šé”å¤±è´¥ä¸ä¼šç©ºè½¬æ¶ˆè€— CPU
- ä¸Šé”æˆåŠŸäº†ä¹Ÿéœ€è¦é€€å‡ºç³»ç»Ÿè°ƒç”¨å†…æ ¸(syscall)ï¼Œè€—æ—¶

### Futex: Fast Userspace muTexes

> ç¼åˆæ€ªï¼ˆå…¨éƒ½è¦

- åŠ é”æˆåŠŸå°±å’Œ Spin lock ä¸€æ ·åªæœ‰ä¸€ä¸ªåŸå­æŒ‡ä»¤å°±å®Œäº†
- åŠ é”å¤±è´¥å°±å’Œç¡çœ é”ä¸€æ ·æ‰§è¡Œç³»ç»Ÿè°ƒç”¨ä¼‘çœ 
- é‡Šæ”¾é”æ—¶å°†åœ¨ç­‰å¾…é”ä¼‘çœ çš„çº¿ç¨‹å”¤é†’

### Compare & Swap (CAS)

- åˆ©ç”¨åŸå­æŒ‡ä»¤ cmpxchg (æ¯”è¾ƒå¹¶äº¤æ¢) æ¥åŸå­æ€§ä¿®æ”¹æŸä¸ªå€¼
- å‡½æ•°ç­¾åä¾‹å¦‚ï¼š func CompareAndSwapInt64(addr \*int64, old, new int64) (swapped bool)

## é¡ºåºä¸€è‡´å¯è§æ€§â€”â€”åŒæ­¥(Synchronization)

> ä¸¤ä¸ªæˆ–ä¸¤ä¸ªä»¥ä¸Šçš„éšç€æ—¶é—´å˜åŒ–çš„é‡åœ¨å˜åŒ–è¿‡ç¨‹ä¸­ä¿æŒä¸€å®šçš„ç›¸å¯¹å…³ç³»

- çº¿ç¨‹åŒæ­¥ï¼šåœ¨æŸä¸€ä¸ªæ—¶é—´ç‚¹å…±åŒè¾¾åˆ°äº’ç›¸å·²çŸ¥çš„çŠ¶æ€

## ç”Ÿäº§è€…&æ¶ˆè´¹è€…

- åŒæ­¥
  > ç”Ÿäº§è€…ï¼šé˜Ÿåˆ—é‡Œæœ‰ç©ºä½å°±ç”Ÿäº§å¡«è¡¥
  > æ¶ˆè´¹è€…ï¼šé˜Ÿåˆ—é‡Œæœ‰å…ƒç´ å°±æ¶ˆè´¹å–å‡º

## æ¡ä»¶å˜é‡(Conditional Variables|CV)

> æ¡ä»¶å˜é‡çš„ API

- wait(cv, mutex)

  > è°ƒç”¨ä¹‹å‰ä¿è¯å·²ç»å–å¾—äº† mutex
  > é‡Šæ”¾ mutex å¹¶è¿›å…¥ç¡çœ 

- signal/notify(cv)

  > å”¤é†’ç­‰å¾… cv çš„çº¿ç¨‹ä¸­å…¶ä¸­ä¸€ä¸ª(é€šå¸¸å”¤é†’åè¦æŠŠé”ç»™å®ƒ)

- broadcast/notifyAll(cv)
  
  > å”¤é†’æ‰€æœ‰ç­‰å¾… cv çš„çº¿ç¨‹(é€šå¸¸å”¤é†’çš„æ‰€æœ‰çº¿ç¨‹éƒ½ä¼šå»äº‰å¤ºè¿™æŠŠé”)

### Java ä¸­çš„ wait å’Œ notify å®ç°å• producer/consumer æ¨¡å‹

> è¿™é‡Œçš„ æ¡ä»¶å˜é‡å’Œé”æ˜¯åŒä¸€ä¸ªå˜é‡ cvAndLock æ¥ä»£è¡¨çš„
> è¿™ä¹Ÿæ˜¯ Java å®ç°æ¡ä»¶å˜é‡åŒæ­¥çš„ä¸€ä¸ªæœºåˆ¶
> å¯¹é”è°ƒç”¨ notify å”¤é†’ä¹‹å‰æŒæœ‰è¿‡è¿™æŠŠé”çš„ç¡çœ çº¿ç¨‹ï¼Œå¹¶æŠŠé”ç»™å®ƒ
> å¯¹é” wait è®©æŒæœ‰è¿™æŠŠé”çš„çº¿ç¨‹ç¡çœ å¹¶æŠŠé”é‡Šæ”¾

```java
public class CV{
    public static void main(String[] args) {
        List<Object> queue = new LinkedList<>();
        Object cvAndLock = new Object();

        Thread producer = new Thread(() -> {
            synchronized(cvAndLock) {
                while (true) {
                    if (queue.size() >= 5) {
                        try {
                            System.out.println("Producer: queue is full, i'll gonna sleep. zzz");
                            cvAndLock.wait();
                            System.out.println("Producer: what? queue is not full? thanks to wake me up!");
                        } catch (Exception ignored) {
                        }
                    }
                    queue.add(new Object());
                    cvAndLock.notify();
                    System.out.println("put one into queue, now queue:" + queue);
                }

            }
        });

        Thread consumer = new Thread(() -> {
            synchronized(cvAndLock) {
                while (true) {
                    if (queue.isEmpty()) {
                        try {
                            System.out.println("Consumer: queue is empty, i'll gonna sleep. zzz");
                            cvAndLock.wait();
                            System.out.println("Consumer: what? queue is not empty? thanks to wake me up!");
                        } catch (Exception ignored) {
                        }
                    }
                    queue.remove(0);
                    cvAndLock.notify();
                    System.out.println("get one from queue, now queue:" + queue);
                }

            }
        });

        producer.start();
        consumer.start();
    }
}
```

### å¤š producer/consumer æ¨¡å‹

> æˆ‘ä»¬å¸Œæœ› producer ä¸­è°ƒç”¨ notify æ—¶ä¼šå”¤é†’ä¸€ä¸ª consumerï¼Œä½†åªæœ‰ä¸€ä¸ªæ¡ä»¶å˜é‡å¯èƒ½ä¼šåˆå”¤é†’ä¸€ä¸ª producer ç”Ÿäº§å¯¼è‡´ bugï¼Œconsumer ä¸­è°ƒç”¨ notify æ—¶åŒç†
> **è§£å†³åŠæ³•ï¼šä¿è¯ä¸èƒ½å”¤é†’äº†é”™è¯¯çš„çº¿ç¨‹ï¼Œæˆ–è€…ä½¿ç”¨ä¸¤ä¸ªæ¡ä»¶å˜é‡**

- Go å®ç° 1

```go
package test

import (
	"fmt"
	"sync"
	"testing"
)

var n, count = 5, 0

func TestSync(t *testing.T) {
	cv := sync.NewCond(&sync.Mutex{})

	for i := 0; i < 8; i++ {
		go Producer(cv)
		go Consumer(cv)
	}

	<-make(chan struct{})
}

func Producer(cond *sync.Cond) {
	for {
		cond.L.Lock()
		for !(count != n) { // to assume count != n
			fmt.Println("=== Produce start waiting...")
			cond.Wait() // if count == n, continue waiting.
		}
		count++
		fmt.Println("produce a num, now:", count)
		cond.L.Unlock()
		cond.Broadcast() // to avoid waking a producer up and cause dead lock
	}

}

func Consumer(cond *sync.Cond) {
	for {
		cond.L.Lock()
		for !(count != 0) { // to assume count != 0
			fmt.Println("=== Consumer start waiting...")
			cond.Wait() // if count == 0, continue waiting.
		}
		count--
		fmt.Println("consume a num, now:", count)
		cond.L.Unlock()
		cond.Broadcast() // to avoid waking a consumer up and cause dead lock
	}
}
```

- Java å®ç° 2

```java
import java.util.concurrent.atomic.AtomicInteger;

public class Test {
    public static void main(String[] args)  {
        AtomicInteger count = new AtomicInteger(); // è¿™é‡Œä¸éœ€è¦Atomicç±»å‹ï¼Œä½†æ˜¯Javaé—­åŒ…åªèƒ½ä¼ é€’å¸¸é‡å€¼(åŸºæœ¬æ•°æ®ç±»å‹æˆ–è€…å¯¹è±¡å¼•ç”¨)
        int n = 5;

        Object cvLock1 = new Object();
        Object cvLock2 = new Object();

        for (int i = 0; i < 8; i++) {
            new Thread(() -> {
                while (true) {
                    synchronized (cvLock1) {
                        while (!(count.get() != n)) {
                            try {
                                cvLock1.wait();
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }
                        assert count.get() != n;
                        count.getAndIncrement();
                        System.out.println("produce a num, now: "+count.get());
                    }
                    synchronized (cvLock2) {
                        cvLock2.notify();
                    }
                }
            }).start();

            new Thread(() -> {
                while (true) {
                    synchronized (cvLock2) {
                        while (!(count.get() != 0)) {
                            try {
                                cvLock2.wait();
                            } catch (InterruptedException e) {
                                e.printStackTrace();
                            }
                        }
                        assert count.get() != 0;
                        count.getAndDecrement();
                        System.out.println("consume a num, now: "+count.get());
                    }
                    synchronized (cvLock1) {
                        cvLock1.notify();
                    }
                }
            }).start();
        }

    }
}
```

> æ•´ä½“è¿‡ç¨‹å°±æ˜¯ï¼š
>
> 1. **åŠ äº’æ–¥é”**
> 1. **å¾ªç¯æ£€æŸ¥æ¡ä»¶æ˜¯å¦ä¸æ»¡è¶³ï¼Œä¸æ»¡è¶³å°±ç¡çœ ç›´è‡³è¢«å”¤é†’ç»§ç»­å¾ªç¯æ£€æŸ¥åˆ°æ»¡è¶³ï¼Œæ»¡è¶³åˆ°ç¬¬ 3 æ­¥**
> 1. **æ–­è¨€æ¡ä»¶æ»¡è¶³(Debug ä½¿ç”¨)**
> 1. **æ‰§è¡Œæ“ä½œ**
> 1. **é‡Šæ”¾äº’æ–¥é”**
> 1. **å¹¿æ’­æ¡ä»¶å˜é‡ï¼Œå”¤é†’æ‰€æœ‰ç¡çœ çš„çº¿ç¨‹**

## ä¿¡å·é‡æœºåˆ¶

> ä¿¡å·é‡ç›¸å½“äºä¸€ä¸ªä»¤ç‰Œ

- P(&sem)ï¼šç­‰å¾…ä¸€ä¸ªä¿¡å·é‡å¹¶è¿”å›ï¼Œæ²¡æœ‰ä¿¡å·é‡åˆ™ä¼šè®©çº¿ç¨‹ä¼‘çœ ç›´åˆ°æœ‰ä¿¡å·é‡æ‰å”¤é†’
- V(&sem)ï¼šäº§ç”Ÿä¸€ä¸ªä¿¡å·é‡ï¼Œå¦‚æœæœ‰ç­‰å¾…ä¿¡å·é‡çš„çº¿ç¨‹å°±æŠŠä¿¡å·é‡ç»™å®ƒï¼Œå¦åˆ™æ”¾åˆ°ä¿¡å·é‡æ± é‡Œ

### å®ç°ç”Ÿäº§è€…æ¶ˆè´¹è€…

```c
void producer() {
    P(&empty); // ä»emptyé‡Œè¯·æ±‚ä¸€ä¸ªä¿¡å·é‡
    count ++;
    V(&fill);  // äº§ç”Ÿä¸€ä¸ªä¿¡å·é‡åˆ°fillé‡Œ
}

void consumer() {
    P(&fill); // ä»fillé‡Œè¯·æ±‚ä¸€ä¸ªä¿¡å·é‡
    count --;
    V(&empty);  // äº§ç”Ÿä¸€ä¸ªä¿¡å·é‡åˆ°emptyé‡Œ
}
```

## ç®¡é“ Channel åŒæ­¥

> ç®¡é“è‡ªå¸¦é˜»å¡ä¸å”¤é†’
> å¯ä»¥å»ºç«‹åœ¨æ¡ä»¶å˜é‡ä¸Šå®ç°

- java å®ç°

```java
class Chan<T> {

    private LinkedList<T> ch = new LinkedList<>();

    private int length;

    public Chan(int length) {
        assert length > 0;
        this.length = length;
    }

    public synchronized T get() {
        while (!(ch.size() != 0)) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        assert ch.size() != 0;
        T ret = ch.removeFirst();
        this.notifyAll();
        return ret;
    }

    public synchronized void put(T v) {
        while (!(ch.size() != length)) {
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        assert ch.size() < length;
        ch.addLast(v);
        this.notifyAll();
    }

    @Override
    public String toString() {
        return "Chan{" +
                "ch=" + ch +
                ", length=" + length +
                '}';
    }
}
```

# ä¸šåŠ¡ä¸Šçš„å¹¶å‘ç¼–ç¨‹

## é«˜æ€§èƒ½è®¡ç®—ç¨‹åº(å•æœºå™¨è¶…ç®—)

> A technology that harmesses the power of supercomputers or computer clusters to solve complex problems requiring massive computation

### æŒ‘æˆ˜

#### è®¡ç®—å›¾å¦‚ä½•åˆ†è§£

- è®¡ç®—å›¾éœ€è¦å®¹æ˜“å¹¶è¡ŒåŒ–
- ç”Ÿäº§è€…/æ¶ˆè´¹è€…æ¨¡å‹è§£å†³åŒæ­¥é—®é¢˜

#### çº¿ç¨‹å¦‚ä½•é€šä¿¡

## æ•°æ®ä¸­å¿ƒçš„å¹¶å‘ç¼–ç¨‹(å¤šæœºå™¨åˆ†å¸ƒå¼)

> A network of computing and storage resources that enable the delivery of shared applications and data

### æŒ‘æˆ˜

- æ•°æ®ä¸€è‡´æ€§ (Consistency)
- æœåŠ¡æ—¶åˆ»ä¿æŒé«˜å¯ç”¨ (Availability)
- å®¹å¿æœºå™¨ç¦»çº¿ (Partition tolerance)

## å•å°æœºå™¨æ•°æ®å¤„ç†çš„å¹¶å‘ç¼–ç¨‹

### å¹¶è¡Œå¤„ç†è¯·æ±‚

- å…³é”®æŒ‡æ ‡: QPS (Query per second), tail latency, ...

### è®¾è®¡å¹¶å‘ç¨‹åºçš„å·¥å…·

1. çº¿ç¨‹

   > æ“ä½œç³»ç»Ÿçš„æœ€å°æ‰§è¡Œå•å…ƒï¼Œä¸Šä¸‹æ–‡åˆ‡æ¢è¾ƒæ…¢
   > çº¿ç¨‹æ“…é•¿å¤„ç†å¯†é›†å‹è®¡ç®—ä»»åŠ¡å’Œ IO ä»»åŠ¡ï¼Œå¯ä»¥åˆ©ç”¨å¾ˆå¤šçš„å¤„ç†å™¨ï¼Œè€Œåç¨‹æ˜¯ OS ä¸å¯è§çš„ï¼Œç”¨æˆ·ä¸åˆç†è°ƒåº¦ä¼šä½¿å¾—å¤„ç†å™¨åˆ©ç”¨ç‡ä½(ä¸€ä¸ªåç¨‹æ‰§è¡Œ io è¿›å…¥ syscall åé˜»å¡å†…æ ¸çº¿ç¨‹ï¼Œå¯¼è‡´è¿™ä¸ªçº¿ç¨‹å‰©ä¸‹çš„åç¨‹å¹²ç­‰[ç”¨æˆ·æ²¡æœ‰æŠŠåç¨‹åˆ‡æ¢åˆ°å¦ä¸€ä¸ªå¤„ç†å™¨çš„æƒ…å†µä¸‹])

2. åç¨‹

   > æ¯”çº¿ç¨‹æ›´è½»é‡ï¼Œåˆ‡æ¢æ›´å¿«
   > åç¨‹æ“…é•¿åˆ‡æ¢ï¼Œå¤„ç†å¤§é‡çš„å¹¶å‘ä»»åŠ¡ï¼Œç”¨æˆ·åˆç†è°ƒåº¦ä¸‹å¯ä»¥é˜²æ­¢å¤§é‡ä»»åŠ¡ä¸Šä¸‹æ–‡åˆ‡æ¢æ—¶é€ æˆå¾ˆå¤§æ€§èƒ½æŸå¤±ï¼›åç¨‹è¿˜å¯ç”¨äºé˜²æ­¢é‡è¦çº¿ç¨‹é˜»å¡ï¼Œå¦‚å®‰å“å¼€å‘ä¸­æ€»æ˜¯æŠŠç½‘ç»œè¯·æ±‚éƒ¨åˆ†æ‰“åŒ…æˆä¸€ä¸ªåç¨‹æ‰”åˆ°å…¶ä»–çº¿ç¨‹å»æ‰§è¡Œï¼Œç„¶åæ‹¿åˆ°è¯·æ±‚ç»“æœåˆ·æ–° UI ç•Œé¢ï¼Œé˜²æ­¢é˜»å¡ UI åˆ·æ–°çš„ä¸»çº¿ç¨‹ï¼Œå¦‚æœç›´æ¥å¦èµ·ä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œç½‘ç»œè¯·æ±‚ä¼šé€ æˆæ€§èƒ½æŸå¤±ï¼Œå³ä½¿ä½¿ç”¨çº¿ç¨‹æ± å‰”é™¤åˆå§‹åŒ–çš„æŸå¤±ä¹Ÿå¯èƒ½ä¼šå› ä¸ºçº¿ç¨‹çš„åˆ‡æ¢æŸå¤±æ€§èƒ½

3. Goroutine
   > ç¼åˆæ€ª
   > è‡ªå¤ç¼åˆæ€ªå¾€å¾€æ˜¯æ€§èƒ½æœ€ä¼˜çš„
   > å®ƒç»“åˆäº†çº¿ç¨‹å’Œåç¨‹çš„ç‰¹ç‚¹ï¼Œå®ç°äº†ä¸Šä¸‹æ–‡åˆ‡æ¢å¿«ï¼Œè°ƒåº¦é è¿è¡Œæ—¶è€Œéç”¨æˆ·(ç”¨æˆ·æ°¸è¿œä¼šå†™å‡ºçª’æ¯çš„è°ƒåº¦æ–¹æ³•ï¼Œä¸å¦‚è‡ªè¡Œè®¾è®¡ä¸€ä¸ªé«˜æ€§èƒ½çš„è°ƒåº¦æ¨¡å‹ "GPM")ï¼Œè¿›ä¸€æ­¥èš•é£Ÿ CPU çš„ä»·å€¼

### å®ç°ç”Ÿäº§è€…æ¶ˆè´¹è€…çš„å·¥å…·â€”â€”åŒæ­¥å¹¶å‘ç¨‹åº

1. æ¡ä»¶å˜é‡
1. ä¿¡å·é‡

   > è§ä¸Šé¢

1. ç®¡é“ Channel
   > **Do not communicate by sharing memory; instead, share memory by communicating.**
   > â€”â€” ã€ŠEffevtive Goã€‹

**å…±äº«å†…å­˜ = ä¸‡æ¶ä¹‹æº**

å¹¶å‘é—®é¢˜æ¥è‡ªäºå…±äº«å†…å­˜çš„å¤±æ•ˆï¼Œä¸ºäº†é˜²æ­¢å…±äº«å†…å­˜å¤±æ•ˆï¼Œåªèƒ½åŠ é”ä¿æŠ¤å®ƒï¼Œäºæ˜¯è¯ç”Ÿäº†å„ç§é”ï¼Œæ¡ä»¶å˜é‡è¿™äº›åŒæ­¥å·¥å…·

å›å¤´æƒ³ä¸€æƒ³ï¼Œä¸ºä»€ä¹ˆè¦å…±äº«å†…å­˜?
æ˜¯å› ä¸ºæˆ‘ä»¬éœ€è¦è®©å…±äº«å†…å­˜å¸®åŠ©æˆ‘ä»¬è¿›è¡Œå¹¶å‘ç¨‹åºé—´çš„é€šä¿¡ã€‚è®©ä¸åŒçº¿ç¨‹ååŠ©å·¥ä½œï¼Œåªéœ€åˆ¶å®šä¸€ä¸ªå…±äº«å†…å­˜åè®®ï¼šjob æ•° å¤§äº 0 æ—¶æ¶ˆè´¹è€…æ¶ˆè´¹ï¼Œjob æ•° ç­‰äº 0 æ—¶ç”Ÿäº§è€…ç”Ÿäº§ã€‚

å¯è®©çº¿ç¨‹é€šä¿¡çœŸçš„åªèƒ½é å…±äº«å†…å­˜å—ï¼Ÿçº¿ç¨‹ä¸­çš„é€šä¿¡çœŸçš„åªèƒ½ç»´æŠ¤ä¸€ä¸ªå…±åŒçš„å…±äº«å†…å­˜åè®®æ¥è¿›è¡Œé€šä¿¡å—ï¼Ÿ
ä¸æ˜¯ï¼
å›å½’åŸå§‹ï¼Œå¦‚æœä¸¤ä¸ªäººéœ€è¦é€šä¿¡æ€ä¹ˆåŠï¼Ÿ
ç›´æ¥å’Œ Ta è¯´ä¸€å£°å°±è¡Œäº†ã€‚é€šä¿¡ä¸åªæœ‰å…±äº«å†…å­˜çš„æ‰‹æ®µï¼Œæƒ³è¦é€šä¿¡ï¼Œåªéœ€ç»´æŠ¤ä¸€ä¸ªçº¿ç¨‹åˆ°çº¿ç¨‹ä¹‹é—´çš„çº¿è·¯ï¼Œçº¿ç¨‹é—´å½¼æ­¤äº¤æµå°±è¡Œäº†ï¼Œè¿™å°±æ˜¯ **share memory by communicating.**

è¿™ä¸ªçº¿è·¯å°±æ˜¯ **Channel**

> Channel å…¶å®å’Œæ¡ä»¶å˜é‡ï¼Œä¿¡å·é‡ä¸æ˜¯åŒä¸€ä¸ªçº§åˆ«çš„ä¸œè¥¿ï¼ŒChannel æœ¬èº«å°±ç®—ä¸€ä¸ªå…±äº«å†…å­˜ï¼Œåªä¸è¿‡å®ƒå’Œæ™®é€šçš„å…±äº«å†…å­˜ä¸ä¸€æ ·çš„æ˜¯ï¼šå®ƒä¸ä½œä¸ºä¸€ä¸ª**ä¿¡å·**å…±äº«å†…å­˜ï¼Œè€Œæ˜¯ä½œä¸ºä¸€ä¸ª**åª’ä»‹**å®ç°*åˆ†äº«*å†…å­˜
> Channel çš„åº•å±‚å®ç°å°±éœ€è¦å…±äº«å†…å­˜ï¼Œä¾‹å¦‚è¦ä¿è¯å¾ˆå¤šæ•°æ®å†™å…¥ Channel æ—¶ä¸ä¼šå‡ºç°å¹¶å‘é—®é¢˜ï¼Œå°±éœ€è¦ä¸€æŠŠå…±äº«çš„äº’æ–¥é”ï¼›å”¤é†’ç­‰å¾… Channel çš„çº¿ç¨‹æ—¶ï¼Œä¹Ÿéœ€è¦ä½¿ç”¨æ¡ä»¶å˜é‡ã€‚

> **Channel æ˜¯ä¸Šå±‚ API å¯¹é”ï¼Œæ¡ä»¶å˜é‡ç­‰åº•å±‚åŒæ­¥å·¥å…·çš„å°è£…æ‰€å½¢æˆçš„ä¸€ç§æ–°çš„åŒæ­¥å·¥å…·ï¼Œè®©ç”¨æˆ·ä¸å†é‡å¤é€ è½®å­ï¼Œä¹Ÿè®©ç”¨æˆ·ä¸å†å› ä¸ºä½¿ç”¨å…±äº«å†…å­˜è¿›è¡Œé€šä¿¡å¯¼è‡´å¹¶å‘é—®é¢˜è€Œè‹¦æ¼**

## äººæœºäº¤äº’(UI)çš„å¹¶å‘ç¼–ç¨‹

### ç‰¹ç‚¹â€”â€”ä¸å¤ªå¤æ‚

1. æ²¡æœ‰å¤ªå¤šæ•°æ®

   > ä¸€ä¸ªé¡µé¢çš„æ•°æ®ä¸ä¼šå¤ªå¤šï¼Œå¤ªå¤šäº†äººä¹Ÿçœ‹ä¸ä¸‹æ¥
   > é¡µé¢çš„æ¸²æŸ“å¸ƒå±€ æµè§ˆå™¨/APP å¯ä»¥è‡ªå·±å¸®æˆ‘ä»¬å®Œæˆ

2. æ²¡æœ‰å¤ªå¤š IO
   
   > ä¸€äº›ç½‘ç»œ IOï¼Œå’Œä¸€äº›é¡µé¢å…ƒç´ è¯»å–çš„ IO

### Javascript å•çº¿ç¨‹ + äº‹ä»¶æ¨¡å‹

> ç¨‹åºä¸²è¡Œæ‰§è¡Œï¼Œæ²¡æœ‰é”çš„æ¦‚å¿µï¼Œä¹Ÿä¸ä¼šå‡ºç°å¹¶å‘é—®é¢˜
> æ¯æ¬¡æ‰§è¡Œéƒ½å®Œæˆä¸€ä¸ªäº‹ä»¶ï¼Œäº‹ä»¶å°±æ˜¯ä¸€ä¸ªåŸå­çš„æ“ä½œ
> ç½‘ç»œ IO è¯·æ±‚ä½¿ç”¨å¼‚æ­¥æ“ä½œåˆ›å»ºä¸€ä¸ªäº‹ä»¶ï¼Œå½“è¯·æ±‚æ‹¿åˆ°ç»“æœæˆ–è€…å¤±è´¥çš„æ—¶å€™å†äº§ç”Ÿä¸€ä¸ªäº‹ä»¶æ¸²æŸ“é¡µé¢

# å¹¶å‘çš„ Debug

> è½¯ä»¶æ˜¯éœ€æ±‚(è§„çº¦)åœ¨è®¡ç®—æœºæ•°å­—ä¸–ç•Œçš„æŠ•å½±

## é˜²å¾¡æ€§ç¼–ç¨‹

> æŠŠç¨‹åºéœ€è¦æ»¡è¶³çš„æ¡ä»¶ç”¨ assert è¡¨è¾¾å‡ºæ¥
> ç¼–å†™ä»£ç æ—¶ä¼šä¸¢å¤±ä¿¡æ¯ï¼Œå¯ç¨‹åºä¸çŸ¥é“è¿™äº›ä¿¡æ¯ï¼Œç®—ä¸€ä¸ªç®€å•çš„å‡æ³•
> å°±å¯èƒ½å‡ºç° 0 - 100 = 4294967196 (æ— ç¬¦å·æ•´æ•°æº¢å‡º)ï¼Œè¿™æ—¶å°±å¯ä»¥è¡¥å……ä¸€äº›ä¿¡æ¯
> ä¾‹å¦‚ assert(0-100 < 0)ï¼Œè¡¥å……ä¸€ä¸ª 0 å‡å»ä¸€ä¸ªæ­£æ•°éƒ½å°äº 0 çš„ä¿¡æ¯ï¼Œä»è€Œå®ç°é˜²å¾¡æ€§ç¼–ç¨‹

## æ­»é”

> A deadlock is a state in while each member of a group is waiting for another member, including itself, to take action.

### å¿…è¦æ¡ä»¶

- äº’æ–¥ï¼šä¸€ä¸ªèµ„æºæ¯æ¬¡åªèƒ½è¢«ä¸€ä¸ªè¿›ç¨‹ä½¿ç”¨
- è¯·æ±‚ä¸ä¿æŒï¼šä¸€ä¸ªè¿›ç¨‹è¯·æ±‚èµ„æºé˜»å¡æ—¶ï¼Œä¸é‡Šæ”¾å·²è·å¾—çš„èµ„æº
- ä¸å‰¥å¤ºï¼šè¿›ç¨‹å·²è·å¾—çš„èµ„æºä¸èƒ½å¼ºè¡Œå‰¥å¤º
- å¾ªç¯ç­‰å¾…ï¼šè‹¥å¹²ä¸ªè¿›ç¨‹ç›´æ¥å½¢æˆå¤´å°¾ç›¸è¿çš„å¾ªç¯ç­‰å¾…èµ„æºå…³ç³»

å®é™…å¼€å‘ä¸­å¾ˆéš¾ç ´åè¿™å››ä¸ªæ¡ä»¶æ¥é¿å…æ­»é”

### é¿å…æ­»é”

#### AA-Deadlock

- AA å‹æ­»é”å®¹æ˜“æ£€æµ‹ï¼ŒåŠæ—©æŠ¥å‘Šï¼ŒåŠæ—©ä¿®å¤

#### ABBA-Deadlock

- ä»»ä½•æ—¶åˆ»ç³»ç»Ÿä¸­çš„é”éƒ½æ˜¯æœ‰é™çš„
- ä¸¥æ ¼æŒ‰ç…§**å›ºå®šçš„é¡ºåº**è·å¾—æ‰€æœ‰é”(æ¶ˆé™¤ "å¾ªç¯ç­‰å¾…")

## æ•°æ®ç«äº‰

> ä¸åŒçš„çº¿ç¨‹åŒæ—¶è®¿é—®åŒä¸€æ®µå†…å­˜ï¼Œä¸”è‡³å°‘æœ‰ä¸€ä¸ªæ˜¯å†™

- ä¸¤ä¸ªå†…å­˜è®¿é—®åœ¨ èµ›è·‘ï¼Œè·‘èµ¢ çš„æ“ä½œå…ˆæ‰§è¡Œ

### é¿å…æ•°æ®ç«äº‰

ç”¨äº’æ–¥é”ä¿æŠ¤å¥½å…±äº«æ•°æ®ï¼Œæ¶ˆç­æ‰€æœ‰æ•°æ®ç«äº‰

## Debug å·¥å…·

### Lockdepâ€”â€”è¿è¡Œæ—¶çš„æ­»é”æ£€æŸ¥

> Lockdep ä¸ºæ¯ä¸€æŠŠé”åˆ†é…ä¸€ä¸ªç¡®å®šå”¯ä¸€çš„ "allocation site"
> å¹¶æ–­è¨€ç³»ç»Ÿä¸­åŒä¸€ä¸ª "allocation site" çš„é”å­˜åœ¨å…¨å±€ä¸”å”¯ä¸€çš„ä¸Šé”é¡ºåº

### ThreadSanitizerâ€”â€”è¿è¡Œæ—¶çš„æ•°æ®ç«äº‰æ£€æŸ¥

> ä¸ºæ‰€æœ‰äº‹ä»¶å»ºç«‹ä¸€ä¸ª happens-before å…³ç³»å›¾
> å¦‚æœå­˜åœ¨æœªè¿æ¥çš„äº‹ä»¶ç‚¹è¯´æ˜å¯èƒ½ä¼šå‘ç”Ÿæ•°æ®ç«äº‰

### åŠ¨æ€ç¨‹åºåˆ†æå·¥å…·â€”â€”Sanitizers

> åœ¨äº‹ä»¶å‘ç”Ÿæ—¶è®°å½•
> è§£æè®°å½•æ£€æŸ¥é—®é¢˜

- AddressSanitizer éæ³•å†…å­˜è®¿é—®
- ThreadSanitizer æ•°æ®ç«äº‰
- MemorySanitizer æœªåˆå§‹åŒ–è¯»å–
- UBSanitizer undefined behavior

# ç»“è¯­

> å¸Œæœ›è¿™äº›å¯¹ä½ æœ‰ç”¨ :)
